package com.epinom.vetusta.musicexperience.controllers{	import caurina.transitions.Tweener;	import caurina.transitions.properties.FilterShortcuts;		import com.digitalsurgeons.loading.BulkLoader;	import com.digitalsurgeons.loading.BulkProgressEvent;	import com.epinom.vetusta.musicexperience.data.DataModel;	import com.epinom.vetusta.musicexperience.data.HashMap;	import com.epinom.vetusta.musicexperience.events.EventComplex;	import com.epinom.vetusta.musicexperience.managers.LocationManager;	import com.epinom.vetusta.musicexperience.ui.Location;	import com.epinom.vetusta.musicexperience.ui.MapCell;	import com.epinom.vetusta.musicexperience.ui.Player;	import com.epinom.vetusta.musicexperience.ui.ToolBar;	import com.epinom.vetusta.musicexperience.ui.VetustaComponent;	import com.epinom.vetusta.musicexperience.utils.NumberUtils;	import com.epinom.vetusta.musicexperience.utils.StageManager;	import com.epinom.vetusta.musicexperience.utils.StringUtils;	import com.epinom.vetusta.musicexperience.utils.XMLParser;	import com.epinom.vetusta.musicexperience.vos.ComponentVO;	import com.epinom.vetusta.musicexperience.vos.InterfaceObject;	import com.epinom.vetusta.musicexperience.vos.LocationVO;	import com.epinom.vetusta.musicexperience.vos.SoundVO;		import fl.controls.Button;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.display.MovieClip;	import flash.display.SimpleButton;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.external.ExternalInterface;	import flash.filters.*;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.net.LocalConnection;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.system.Security;	import flash.system.SecurityDomain;	import flash.system.System;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.utils.Timer;	import flash.utils.getDefinitionByName;		public class VetustaMusicExperienceAppController extends Sprite	{		/**		 * @property		 * Objeto responsable de cargas multiples de ficheros externos		 */		private var bulkLoader:BulkLoader;				/**		 * @property		 * Objeto contenedor de variables externas enviadas desde el HTML/PHP		 */		private var flashvars:Object;				/**		 * @property		 * Variables para comunicacion entre AS3 y Javascript en un entorno Facebook		 */		private var connection:LocalConnection; 		private var connectionName:String;				/**		 * @property		 * Referencia al swf "main.swf"		 */		private var mainMovieClip:MovieClip;		private var mainLoader:Loader;				/**		 * @property		 * Referencia al swf pajaros		 */		private var birdsAnimation:MovieClip;				/**		 * @property		 * Timer para contar los segundos que se reproduce la cancion hasta que el usuario comienza su experiencia		 */		private var soundTimer:Timer;		private var soundSecondCounter:uint;		private var playingSoundIndex:uint				/**		 * @property		 * Variables que se utilizaran como referencias de objetos visuales		 */								private var vetustaVisualLoader:MovieClip;			private var vetustaVisualLoader_io:InterfaceObject;		private var highResolutionMap:MovieClip;			private var highResolutionMap_io:InterfaceObject;		private var toolBar:MovieClip;			private var toolBar_io:InterfaceObject;		private var boundsMap:MovieClip;			private var boundsMap_io:InterfaceObject;		private var blackBackground:MovieClip;			private var blackBackground_io:InterfaceObject;		private var lowResolutionMap:MovieClip;			private var lowResolutionMap_io:InterfaceObject;		private var modalPanel:MovieClip;			private var modalPanel_io:InterfaceObject;		private var wizardModalWindow:MovieClip;			private var wizardModalWindow_io:InterfaceObject;		private var blurTransition:MovieClip;			private var blurTransition_io:InterfaceObject;				/**		 * @property		 * Mapa		 */		private var cellIdList:Array;		private var cellHashMap:HashMap;		private var secondCounter:uint;		private var map:Sprite;		private var actualRandomPointToMarker:Point;		private var actualCellForExperience:MapCell;		private var actualMarker:MovieClip;		private var actualPin:MovieClip;		private var actualLocationVO:LocationVO;		private var actualPercentageScaleMap:Number;		private var isLockMapControl:Boolean;		private var localPoint:Point;		private var globalPoint:Point;		private var mapOutOfBoundsType:String;		private var isMapMoveCancel:Boolean;		private var isAutomaticAdjustmentExcecuted:Boolean;				/**		 * @property		 * Datos del usuario de Facebook		 */		private var fbUserToken:String;		private var fbUserName:String;		private var fbUrlUserImage:String;		private var fbUserImage:Bitmap;				/**		 * @property		 * Variables temporales		 */						public function VetustaMusicExperienceAppController()		{			super();			debug("VetustaMusicExperienceAppController->VetustaMusicExperienceAppController()");						// Declarando metodos para ser ejecutados desde JavaScript			if (ExternalInterface.available) {				try {					debug("Flash: Adding callback...");					ExternalInterface.addCallback("sendToActionScript", FBloggedIn);					if (checkJavaScriptReady()) {						debug("Flash: JavaScript is ready.");					} else {						debug("Flash: JavaScript is not ready.");					}				} catch (error:SecurityError) {					debug("Flash: A SecurityError occurred: " + error.message);				} catch (error:Error) {					debug("Flash: An Error occurred: " + error.message);				}			} else {				debug("Flash: External interface is not available for this container.");			}						System.useCodePage = false;			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;						// Initialize the shortcuts			FilterShortcuts.init();						if(DataModel.URL_ACTIVE_DOMAIN != "")			{				Security.allowInsecureDomain("*");				Security.allowDomain("*");				Security.allowDomain(DataModel.URL_ACTIVE_DOMAIN + "app.swf");				Security.allowDomain(DataModel.URL_ACTIVE_DOMAIN + "main.swf");				Security.loadPolicyFile(DataModel.URL_ACTIVE_DOMAIN + "crossdomain.xml");			}						// Actualizando la referencia al escenario de la pelicula principal			DataModel.getInstance().stage = this.stage;						// Inicializando propiedades			flashvars = null;				isLockMapControl = true;			isMapMoveCancel = false;			isAutomaticAdjustmentExcecuted = false;						// Inicializando timer			soundTimer = new Timer(1*1000);		// Una vez activado se ejecuta cada 1 SEGUNDO			soundTimer.addEventListener(TimerEvent.TIMER, countSeconds);			soundSecondCounter = 0;			playingSoundIndex = 0;						// Inicializando aplicacion			init();		}				public function debug(text:Object):void 		{			trace(text.toString());			if(ExternalInterface.available)				ExternalInterface.call("console.log", text.toString());		}				private function checkJavaScriptReady():Boolean {			var isReady:Boolean = ExternalInterface.call("isReady");			return isReady;		}				/**		 * @method		 * Inicializa la apicacion		 */		private function init():void		{			trace("VetustaMusicExperienceAppController->init()");			// Iniciando carga de elementos externos			bulkLoader = new BulkLoader(DataModel.MAIN_BULKLOADER_NAME);			bulkLoader.logLevel = BulkLoader.LOG_INFO;						// Estableciendo URL del fichero de configuracion			DataModel.getInstance().settings.settingsXMLLocation = DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_XML_SETTINGS;						// Configurando detectores de eventos			this.loaderInfo.addEventListener(Event.COMPLETE, onLoaderComplete);			}				private function configHandlersForTracksInMap():void		{			for(var i:int = 0; i < DataModel.TOTAL_TRACKS_OF_THE_DISC; i++)				((wizardModalWindow as MovieClip)["track_" + i] as SimpleButton).addEventListener(MouseEvent.CLICK, userSelectedTrack);						// Configurando indicador de actividad para la carga de sonido de la ventana modal			toolBar.playerComponent.activityIndicator = wizardModalWindow.activityIndicatorWithText;			toolBar.playerComponent.modalLayerButton = wizardModalWindow.modalLayerButton;						// Configurando detector de eventos para saber cuando se ha cargado el sonido seleccionado por el usuario			toolBar.playerComponent.addEventListener(DataModel.SOUND_SELECTED_LOADED, changeWizardToNextScreen);		}				/**		 * @event		 * Ejecuta acciones una vez terminada de cargarse la pelicula principal "app.swf"		 */		private function onLoaderComplete(evt:Event):void 		{				trace("VetustaMusicExperienceAppController->onLoaderComplete()");						// Obteniendo flashvars			flashvars = (this.root.loaderInfo as LoaderInfo).parameters;						// Pasando flashvars al modelo de datos								if(flashvars != null) {				//(console as TextField).appendText("\nPasando flashvars al modelo de datos");				DataModel.getInstance().flashvars = flashvars;			}						// Inicializando propiedades			cellIdList = new Array();			cellHashMap = new HashMap();			secondCounter = 0;			// Creando objeto de datos referente al loader visual			var vetustaVisualLoaderVO:ComponentVO = new ComponentVO();			vetustaVisualLoaderVO.type = "MovieClip";			vetustaVisualLoaderVO.className = "VetustaVisualLoader";			vetustaVisualLoaderVO.instanceName = "vetustaVisualLoader";			vetustaVisualLoaderVO.visible = true;			vetustaVisualLoaderVO.hashId = "vetustaVisualLoader";			vetustaVisualLoaderVO.url = "";			vetustaVisualLoaderVO.changeSize = false;			vetustaVisualLoaderVO.percentageWidth = -1;			vetustaVisualLoaderVO.percentageHeight = -1;			vetustaVisualLoaderVO.changePositionX = true;			vetustaVisualLoaderVO.changePositionY = true;			vetustaVisualLoaderVO.percentageX = 50;			vetustaVisualLoaderVO.percentageY = 50;			vetustaVisualLoaderVO.centralReference = false;			vetustaVisualLoaderVO.elementOrder = -1;			vetustaVisualLoaderVO.yPosition = -1;			vetustaVisualLoaderVO.percentagePadding = false;			vetustaVisualLoaderVO.paddingTop = -1;			vetustaVisualLoaderVO.paddingBottom = -1;			vetustaVisualLoaderVO.paddingLeft = -1;			vetustaVisualLoaderVO.paddingRight = -1;									// Creando un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var VetustaVisualLoader:Class = getDefinitionByName(vetustaVisualLoaderVO.className) as Class;						// Creando objeto de tipo BtobLoader			vetustaVisualLoader = new VetustaVisualLoader();			vetustaVisualLoader.name = vetustaVisualLoaderVO.instanceName;						// Creo un objeto de tipo InterfaceObject			vetustaVisualLoader_io = new InterfaceObject(vetustaVisualLoader,														vetustaVisualLoaderVO.className,														vetustaVisualLoaderVO.instanceName,														vetustaVisualLoaderVO.hashId,														vetustaVisualLoaderVO.changeSize,														vetustaVisualLoaderVO.percentageWidth,														vetustaVisualLoaderVO.percentageHeight,														vetustaVisualLoaderVO.changePositionX,														vetustaVisualLoaderVO.changePositionY,														vetustaVisualLoaderVO.percentageX,														vetustaVisualLoaderVO.percentageY);							// Agregando objeto al escenario			StageManager.getInstance().addObject(vetustaVisualLoaderVO.hashId, vetustaVisualLoader_io, vetustaVisualLoaderVO.visible);						// Actualizando modelo de datos			var visualLoaderComponent:VetustaComponent = new VetustaComponent(vetustaVisualLoaderVO, vetustaVisualLoader_io, vetustaVisualLoader);			DataModel.getInstance().componentList.push(visualLoaderComponent);						// Configurando la carga multiple de los elementos necesario para construir la interfaz						// Peticion de carga de XML de configuracion de la aplicacion y la configuracion de todos los componentes para la Diagramacion Liquida			bulkLoader.add(new URLRequest(DataModel.getInstance().settings.settingsXMLLocation), { id:DataModel.getInstance().settings.settingsXMLLocation });						// Peticion de carga de SWF externo que contiene todos los componentes (movieclips) en la biblioteca para la interfaz			bulkLoader.add(new URLRequest(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAIN_SWF), { id:DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAIN_SWF });						// Peticion de carga de animaciones externas			bulkLoader.add(new URLRequest(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_ANIMATIONS + "birds.swf"), { id:DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_ANIMATIONS + "birds.swf"});						// Configurando manejadores de eventos independientes para cada elemento			bulkLoader.get(DataModel.getInstance().settings.settingsXMLLocation).addEventListener(Event.COMPLETE, onXMLSettingsLoaded);			bulkLoader.get(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAIN_SWF).addEventListener(Event.COMPLETE, onSWFMainLoaded);			bulkLoader.get(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_ANIMATIONS + "birds.swf").addEventListener(Event.COMPLETE, onAnimationLoaded);						// Generando listado con nombres de imagenes del mapa			runImagesGenerator();						// Haciendo peticion multiple de imagenes			cellHashMap.actionsForElements(loadImageToMapCell);						// Configurando manejadores de eventos globales para todos elementos			bulkLoader.addEventListener(BulkLoader.COMPLETE, onBulkElementLoadedHandler);			bulkLoader.addEventListener(BulkLoader.PROGRESS, onBulkElementProgressHandler);			bulkLoader.addEventListener(BulkLoader.ERROR, onErrorHandler);						// Iniciando carga multiple			bulkLoader.start();		}				/**		 * @method		 * Genera los nombre de imagenes de todas las celdas del mapa.		 * Crea Tabla Hash con objetos que representa las celdas del mapa		 */		private function runImagesGenerator():void		{			// Configurando variables para el calculo de identificador de imagen			var letterIndex:uint = 0;			var blockIndex:uint = 0;			var cellRowIndex:uint = 0;			var cellColumnIndex:uint = 0;			var actualLetter:String = "";			var actualBlockId:String = "";			var actualCellRowId:String = "";			var actualCellColumnId:String = "";			var imageName:String = ""; 			var counter:uint = 0;						// Adicionando peticiones al loader multiple			for (var i:int = 0; i < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; i++) 			{				if(i == 3)					break;								// Calculando el indice para obtener la letra del cuadrante				letterIndex = i % 3;								// Obteniendo letra del cuadrante				actualLetter = DataModel.LETTERS_BLOCK_LIST[letterIndex];								for (var j:int = 0; j < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; j++) 				{					if(j == 3)						break;										// Calculando el ID del bloque					blockIndex = j % 3;										// Obteniendo el string del ID del bloque					actualBlockId = blockIndex.toString();										for (var k:int = 0; k < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; k++) 					{						// Calculando el indice de la celda en las filas						cellRowIndex = k;												// Obteniendo el string del ID de la celda en las filas						actualCellRowId = DataModel.CELLS_ID_LIST[cellRowIndex];												for (var i2:int = 0; i2 < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; i2++) 						{							// Calculando el indice de la celda en las columnas							cellColumnIndex = i2;														// Obteniendo el string del ID de la celda en las columnas							actualCellColumnId = DataModel.CELLS_ID_LIST[cellColumnIndex];														// Obteniendo el punto con la posicion del bloque en el mapa							var cellPoint:Point = offsetCellPointOfMap(letterIndex, blockIndex, cellRowIndex, cellColumnIndex);														// Creando objeto que representa una celda del mapa							var mapCell:MapCell = new MapCell();							mapCell.idCell = actualLetter + actualBlockId + "-" + actualCellRowId + actualCellColumnId;							mapCell.idGrid = actualCellRowId + actualCellColumnId;							mapCell.idBlock = actualLetter + actualBlockId;							mapCell.imageName = actualLetter + actualBlockId + "-" + actualCellRowId + actualCellColumnId + ".jpg";							//mapCell.urlImageServer = DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_IMAGES + mapCell.imageName;							mapCell.urlImageServer = DataModel.URL_RELATIVE_FOR_MAP_IMAGES + mapCell.imageName;							mapCell.mcName = actualLetter + actualBlockId + "-" + actualCellRowId + actualCellColumnId + ".swf";							if(DataModel.getInstance().animationHashmap.getValue(mapCell.idCell) != null) {								mapCell.urlMovieClipServer = DataModel.URL_RELATIVE_FOR_MAP_MOVIECLIPS + mapCell.mcName;							}							mapCell.image = null;							mapCell.mc = null;							mapCell.loadPriority = 0;							mapCell.offsetX = cellPoint.x;							mapCell.offsetY = cellPoint.y;														// Adicionando nombre de imagen a la lista							cellHashMap.add(mapCell.idCell, mapCell);														//trace(counter + ".- ", mapCell.imageName + "		x: " + mapCell.offsetX + "	  	  y: " + mapCell.offsetY);							counter++;						}					}				}				}			}				/**		 * @method		 * Calcula la posicion de la celda en el mapa		 */		private function offsetCellPointOfMap(letterIndex:uint, blockIndex:uint, cellRowIndex:uint, cellColumnIndex:uint):Point		{				// Inicializando punto			var cellPoint:Point = new Point();						// Calculando posicion de la celda en el mapa segun los parametros 			cellPoint.x = (blockIndex * DataModel.MAP_BLOCK_WIDTH) + (cellColumnIndex * DataModel.MAP_CELL_WIDTH) - DataModel.MAP_REAL_WIDTH / 2;			cellPoint.y = (letterIndex * DataModel.MAP_BLOCK_HEIGHT) + (cellRowIndex * DataModel.MAP_CELL_HEIGHT) - DataModel.MAP_REAL_HEIGHT / 2;						return cellPoint;		}				/**		 * @method		 * Hace la peticion de cada una de las imagenes del mapa al servidor, a traves del gestor multiple de ficheros externos		 */		public function loadImageToMapCell(mapCell:MapCell):void		{			// Lanzando la carga de la imagen			bulkLoader.add(new URLRequest(mapCell.urlImageServer), {id: mapCell.imageName});			// Si una imagen tiene asociado una animacion que va anclada a la posicion de su celda			if(DataModel.getInstance().animationHashmap.getValue(mapCell.idCell) != null) {				bulkLoader.add(new URLRequest(mapCell.urlMovieClipServer), {id: mapCell.mcName});			}		}				/**		 * @method		 * Obtiene la imagen cargado por el gestor de carga de ficheros externo segun el ID de la imagen.		 * Posiciona la imagen y la agrega al escenario		 */		public function setImageToMapCell(mapCell:MapCell):void		{			// Obteniendo la imagen segun su identificador de celda			mapCell.image = bulkLoader.getBitmap(mapCell.imageName);			mapCell.image.smoothing = true;						// Si una imagen tiene asociado una animacion que va anclada a la posicion de su celda			if(DataModel.getInstance().animationHashmap.getValue(mapCell.idCell) != null) {				mapCell.mc = bulkLoader.getMovieClip(mapCell.mcName);				trace("Animation loaded: ", mapCell.mcName);			}						// Posicionando la imagen y adicionandola en la posicion de celda calculada			mapCell.image.x = mapCell.offsetX;			mapCell.image.y = mapCell.offsetY;						// Posicionando animacion, anclando animacion a la posicion de la celda correspondiente			if(mapCell.mc != null) {				mapCell.mc.x = mapCell.offsetX;				mapCell.mc.y = mapCell.offsetY;			}						// Adicionando ID textual al movieclip para identificar en mapa			var idTxt:TextField = textFieldCreate(mapCell.idCell, 0, "#ffffff");			var position:String = "(" + mapCell.offsetX + "; " + mapCell.offsetY + ")";			var positionTxt:TextField = textFieldCreate(position, 0, "#ffffff");						// Posicionando textos identificativos de celda			idTxt.x = mapCell.offsetX; 			idTxt.y = mapCell.offsetY;			positionTxt.x = mapCell.offsetX; 			positionTxt.y = mapCell.offsetY + 20; 						// Adicionando elementos visuales al mapa			highResolutionMap.addChild(mapCell.image);			/*if(mapCell.mc != null)				highResolutionMap.addChild(mapCell.mc);*/			//highResolutionMap.addChild(idTxt);			//highResolutionMap.addChild(positionTxt);									/*			// Creando movieclip adjunto			mapCell.mc = new MovieClip();			mapCell.mc.addChild(mapCell.image);						// Adicionando animacion a la celda si es que la tiene			mapCell.mc.addChild(mapCell.mc);						// Posicionando la imagen y adicionandola en la posicion de celda calculada			mapCell.mc.x = mapCell.offsetX;			mapCell.mc.y = mapCell.offsetY;						// Adicionando ID textual al movieclip para identificar en mapa			var idTxt:TextField = textFieldCreate(mapCell.idCell, 0, "#ffffff");			var position:String = "(" + mapCell.offsetX + "; " + mapCell.offsetY + ")";			var positionTxt:TextField = textFieldCreate(position, 0, "#ffffff");			positionTxt.y = 20; 			mapCell.mc.addChild(idTxt);			mapCell.mc.addChild(positionTxt);						// Adicionando contenedor al mapa			highResolutionMap.addChild(mapCell.mc);			*/					}				private function setMCToMapCell(mapCell:MapCell):void		{			if(mapCell.mc != null)				highResolutionMap.addChild(mapCell.mc);		}				private function textFieldCreate(texto:String, alturax:Number, color:String)		{			var ftextoN:TextField = new TextField();			ftextoN.wordWrap = true;			ftextoN.selectable = false;			ftextoN.type = TextFieldType.DYNAMIC;			ftextoN.x = 10;			ftextoN.y = alturax;			ftextoN.width = 600;			ftextoN.height = 100;			ftextoN.htmlText = '<FONT FACE="_sans" SIZE="12" COLOR="'+color+'" LETTERSPACING="0" KERNING="0">' + texto + '</FONT>';         			return ftextoN;		}				/**		 * @event		 * Ejecuta acciones una vez terminada la descarga del fichero XML de configuracion		 */		public function onXMLSettingsLoaded(evt:Event):void 		{			trace("VetustaMusicExperienceAppController->onXMLSettingsLoaded()");						// Desactivando detectores de eventos			bulkLoader.get(DataModel.getInstance().settings.settingsXMLLocation).removeEventListener(Event.COMPLETE, onXMLSettingsLoaded);						// Obteniendo XML			var xmlSettings:XML = bulkLoader.getXML(DataModel.getInstance().settings.settingsXMLLocation);						// Parseando fichero XML de configuracion			DataModel.getInstance().settings = XMLParser.parseSettingsXML(xmlSettings, DataModel.getInstance().settings);						// Configurando StageManage			StageManager.getInstance().config(DataModel.getInstance().settings.resolution.width, DataModel.getInstance().settings.resolution.height);		}				/**		 * @event		 * Ejecuta acciones una vez terminada la descarga del fichero de animaciones			 */		public function onAnimationLoaded(evt:Event):void 		{			trace("VetustaMusicExperienceAppController->onAnimationLoaded()");						// Desactivando detectores de eventos			bulkLoader.get(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_ANIMATIONS + "birds.swf").removeEventListener(Event.COMPLETE, onAnimationLoaded);						// Recupero el swf cargado (MAIN.SWF)			birdsAnimation = bulkLoader.getMovieClip(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_ANIMATIONS + "birds.swf");		}				/**		 * @event		 * Ejecuta acciones una vez terminada la descarga del fichero SWF que contiene los componentes			 */		public function onSWFMainLoaded(evt:Event):void 		{			trace("VetustaMusicExperienceAppController->onSWFMainLoaded()");						// Desactivando detectores de eventos			bulkLoader.get(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAIN_SWF).removeEventListener(Event.COMPLETE, onXMLSettingsLoaded);						// Recupero el swf cargado (MAIN.SWF)			mainMovieClip = bulkLoader.getMovieClip(DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAIN_SWF);									// BACKGROUND NEGRO 						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var blackBackgroundVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_BLACK_BACKGROUND_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var BlackBackground:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(blackBackgroundVO.className) as Class;						// Creo un objetos de tipo BlackBackground			blackBackground = new BlackBackground();						// Creo objetos de tipo InterfaceObject			blackBackground_io = new InterfaceObject(blackBackground,													blackBackgroundVO.className,													blackBackgroundVO.instanceName,													blackBackgroundVO.hashId,													blackBackgroundVO.changeSize,													blackBackgroundVO.percentageWidth,													blackBackgroundVO.percentageHeight,													blackBackgroundVO.changePositionX,													blackBackgroundVO.changePositionY,													blackBackgroundVO.percentageX,													blackBackgroundVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(blackBackgroundVO.hashId, blackBackground_io, blackBackgroundVO.visible);									// Actualizando modelo de datos			var blackBackgroundComponent:VetustaComponent = new VetustaComponent(blackBackgroundVO, blackBackground_io, blackBackground);			DataModel.getInstance().componentList.push(blackBackgroundComponent);									// MAPA A BAJA RESOLUCION Y ESCALADO 						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var lowResolutionMapVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_LOW_RESOLUTION_MAP_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var LowResolutionMap:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(lowResolutionMapVO.className) as Class;						// Creo un objetos de tipo LowResolutionMap			lowResolutionMap = new LowResolutionMap();			lowResolutionMap.width = DataModel.MAP_REAL_WIDTH;			lowResolutionMap.height = DataModel.MAP_REAL_HEIGHT;			lowResolutionMap.scaleX *= .25;			lowResolutionMap.scaleY *= .25;						// Creo objetos de tipo InterfaceObject			lowResolutionMap_io = new InterfaceObject(lowResolutionMap,														lowResolutionMapVO.className,														lowResolutionMapVO.instanceName,														lowResolutionMapVO.hashId,														lowResolutionMapVO.changeSize,														lowResolutionMapVO.percentageWidth,														lowResolutionMapVO.percentageHeight,														lowResolutionMapVO.changePositionX,														lowResolutionMapVO.changePositionY,														lowResolutionMapVO.percentageX,														lowResolutionMapVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(lowResolutionMapVO.hashId, lowResolutionMap_io, lowResolutionMapVO.visible);									// Actualizando modelo de datos			var lowResolutionMapComponent:VetustaComponent = new VetustaComponent(lowResolutionMapVO, lowResolutionMap_io, lowResolutionMap);			DataModel.getInstance().componentList.push(lowResolutionMapComponent);													// MAPA ALTA RESOLUCION SIN ESCALAR						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var highResolutionMapVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_HIGH_RESOLUTION_MAP_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var HighResolutionMap:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(highResolutionMapVO.className) as Class;						// Creo un objetos de tipo HighResolutionMap			highResolutionMap = new HighResolutionMap();			//highResolutionMap.cacheAsBitmap = true;						// Creo objetos de tipo InterfaceObject			highResolutionMap_io = new InterfaceObject(highResolutionMap,														highResolutionMapVO.className,														highResolutionMapVO.instanceName,														highResolutionMapVO.hashId,														highResolutionMapVO.changeSize,														highResolutionMapVO.percentageWidth,														highResolutionMapVO.percentageHeight,														highResolutionMapVO.changePositionX,														highResolutionMapVO.changePositionY,														highResolutionMapVO.percentageX,														highResolutionMapVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(highResolutionMapVO.hashId, highResolutionMap_io, highResolutionMapVO.visible);									// Actualizando modelo de datos			var highResolutionMapComponent:VetustaComponent = new VetustaComponent(highResolutionMapVO, highResolutionMap_io, highResolutionMap);			DataModel.getInstance().componentList.push(highResolutionMapComponent);										// BARRA DE HERRAMIENTAS						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var toolBarVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_TOOL_BAR_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var ToolBar:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(toolBarVO.className) as Class;						// Creo un objetos de tipo ToolBar			toolBar = new ToolBar();			toolBar.alpha = 0;						// Configurando detector de eventos 			//toolBar.addEventListener(DataModel.ZOOM_EVENT, updateMapWithZoom);									// Inhabilitando controles de la barra de herramientas			toolBar.lockLayer.visible = true;			toolBar.lockLayer.useHandCursor = false;									// Creo objetos de tipo InterfaceObject			toolBar_io = new InterfaceObject(toolBar,				toolBarVO.className,				toolBarVO.instanceName,				toolBarVO.hashId,				toolBarVO.changeSize,				toolBarVO.percentageWidth,				toolBarVO.percentageHeight,				toolBarVO.changePositionX,				toolBarVO.changePositionY,				toolBarVO.percentageX,				toolBarVO.percentageY, 				false, -1, -1, -1, -1,				toolBarVO.percentagePadding, 				toolBarVO.paddingTop, 				toolBarVO.paddingBottom, 				toolBarVO.paddingLeft, 				toolBarVO.paddingRight);								// Agregando objeto al escenario			StageManager.getInstance().addObject(toolBarVO.hashId, toolBar_io, toolBarVO.visible);									// Actualizando modelo de datos			var toolBarComponent:VetustaComponent = new VetustaComponent(toolBarVO, toolBar_io, toolBar);			DataModel.getInstance().componentList.push(toolBarComponent);										// TRANSICION BLUR						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var blurTransitionVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_BLUR_TRANSITION_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var BlurTransition:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(blurTransitionVO.className) as Class;						// Creo un objetos de tipo BlurTransition			blurTransition = new BlurTransition();			//blurTransition.visible = false;						// Creo objetos de tipo InterfaceObject			blurTransition_io = new InterfaceObject(blurTransition,				blurTransitionVO.className,				blurTransitionVO.instanceName,				blurTransitionVO.hashId,				blurTransitionVO.changeSize,				blurTransitionVO.percentageWidth,				blurTransitionVO.percentageHeight,				blurTransitionVO.changePositionX,				blurTransitionVO.changePositionY,				blurTransitionVO.percentageX,				blurTransitionVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(blurTransitionVO.hashId, blurTransition_io, blurTransitionVO.visible);									// Actualizando modelo de datos			var blurTransitionComponent:VetustaComponent = new VetustaComponent(blurTransitionVO, blurTransition_io, blurTransition);			DataModel.getInstance().componentList.push(blurTransitionComponent);									// FRONTERAS DEL MAPA						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var boundsMapVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_BOUNDS_MAP_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var BoundsMap:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(boundsMapVO.className) as Class;						// Creo un objetos de tipo BoundsMap			boundsMap = new BoundsMap();						// Creo objetos de tipo InterfaceObject			boundsMap_io = new InterfaceObject(boundsMap,											boundsMapVO.className,											boundsMapVO.instanceName,											boundsMapVO.hashId,											boundsMapVO.changeSize,											boundsMapVO.percentageWidth,											boundsMapVO.percentageHeight,											boundsMapVO.changePositionX,											boundsMapVO.changePositionY,											boundsMapVO.percentageX,											boundsMapVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(boundsMapVO.hashId, boundsMap_io, boundsMapVO.visible);									// Actualizando modelo de datos			var boundsMapComponent:VetustaComponent = new VetustaComponent(boundsMapVO, boundsMap_io, boundsMap);			DataModel.getInstance().componentList.push(highResolutionMapComponent);										// PANEL MODAL CIRCULAR						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var modalPanelVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_MODAL_PANEL_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var VetustaModalPanel:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(modalPanelVO.className) as Class;						// Creo un objetos de tipo VetustaModalPanel			modalPanel = new VetustaModalPanel();							// Creo objetos de tipo InterfaceObject			modalPanel_io = new InterfaceObject(modalPanel,												modalPanelVO.className,												modalPanelVO.instanceName,												modalPanelVO.hashId,												modalPanelVO.changeSize,												modalPanelVO.percentageWidth,												modalPanelVO.percentageHeight,												modalPanelVO.changePositionX,												modalPanelVO.changePositionY,												modalPanelVO.percentageX,												modalPanelVO.percentageY);																// Agregando objeto al escenario			StageManager.getInstance().addObject(modalPanelVO.hashId, modalPanel_io, modalPanelVO.visible);									// Actualizando modelo de datos			var modalPanelComponent:VetustaComponent = new VetustaComponent(modalPanelVO, modalPanel_io, modalPanel);			DataModel.getInstance().componentList.push(modalPanelComponent);										// VENTANA WIZARD						// Creo un objeto de tipo Class para luego crear objetos del tipo del className cargado por xml			var wizardModalWindowVO:ComponentVO = DataModel.getInstance().settings.getComponentByHash(DataModel.COMPONENT_WIZARD_MODAL_WINDOW_HASH);											// Creo una clase correspondiente al objeto en la biblioteca del swf			var WizardModalWindow:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition(wizardModalWindowVO.className) as Class;						// Creo un objetos de tipo WizardModalWindow			wizardModalWindow = new WizardModalWindow();			(wizardModalWindow.beginVetustaExperience as MovieClip).buttonMode = true;			(wizardModalWindow.beginVetustaExperience as MovieClip).useHandCursor = true;			(wizardModalWindow.beginVetustaExperience as MovieClip).addEventListener(MouseEvent.CLICK, buildInterface);			(wizardModalWindow.beginVetustaExperience as MovieClip).addEventListener(MouseEvent.MOUSE_OVER, function(evt:MouseEvent):void {																	(wizardModalWindow.beginVetustaExperience as MovieClip).gotoAndStop("on");																});						(wizardModalWindow.beginVetustaExperience as MovieClip).addEventListener(MouseEvent.MOUSE_OUT, function(evt:MouseEvent):void {																	(wizardModalWindow.beginVetustaExperience as MovieClip).gotoAndStop("off");																});						(wizardModalWindow.fbConnectButton as SimpleButton).addEventListener(MouseEvent.CLICK, connectWithFacebook);			(wizardModalWindow.activityIndicatorWizardModalWindow as MovieClip).visible = false;			(wizardModalWindow as MovieClip).addEventListener(DataModel.SOUND_SELECTED_IN_WIZARD_MODAL_WINDOW_EVENT, function(evt:Event):void {																	trace("Evento capturado: ", evt.type);																	soundTimer.start();																});			(wizardModalWindow as MovieClip).addEventListener(DataModel.CONFIG_HANDLERS_FOR_TRACKS_IN_MAP, function(evt:Event):void {																	trace("Evento capturado: ", evt.type);																	configHandlersForTracksInMap();																});						if(!DataModel.FACEBOOK_LOCAL_USER_ACTIVE)				ExternalInterface.addCallback("FBloggedIn", FBloggedIn);			this.addEventListener(DataModel.FACEBOOK_LOGGED_IN_EVENT, FBloggedIn);						wizardModalWindow.visible = false;						// Creo objetos de tipo InterfaceObject			wizardModalWindow_io = new InterfaceObject(wizardModalWindow,														wizardModalWindowVO.className,														wizardModalWindowVO.instanceName,														wizardModalWindowVO.hashId,														wizardModalWindowVO.changeSize,														wizardModalWindowVO.percentageWidth,														wizardModalWindowVO.percentageHeight,														wizardModalWindowVO.changePositionX,														wizardModalWindowVO.changePositionY,														wizardModalWindowVO.percentageX,														wizardModalWindowVO.percentageY);								// Agregando objeto al escenario			StageManager.getInstance().addObject(wizardModalWindowVO.hashId, wizardModalWindow_io, wizardModalWindowVO.visible);									// Actualizando modelo de datos			var wizardModalWindowComponent:VetustaComponent = new VetustaComponent(wizardModalWindowVO, wizardModalWindow_io, wizardModalWindow);			DataModel.getInstance().componentList.push(wizardModalWindowComponent);								// LOADER (cambio de nivel de visualizacion)						// Cambio de nivel de visualizacion de BtobLoader para que este en la capa maxima de la lista de visualizacion			var io:InterfaceObject = StageManager.getInstance().removeObject(DataModel.COMPONENT_VISUAL_LOADER_HASH);											// Actualizando refenrecias al loader			vetustaVisualLoader_io = io;			vetustaVisualLoader = io.interactiveObject as MovieClip;							// Adicionando al escenario			StageManager.getInstance().addObject(DataModel.COMPONENT_VISUAL_LOADER_HASH, vetustaVisualLoader_io, true);					}				private function buildInterface(evt:MouseEvent = null):void		{			// Invisibilizando la ventana de wizard inicial			wizardModalWindow.visible = false;						// Invisivilizando panel modal			modalPanel.visible = false;						/* 			Adicionando la imagen cargada a cada celda del mapa que esta almacena en el hashmap, 			se utiliza un demonio para esta funcion, o sea, se le pasa una funcion como referencia "setImageToMapCell", 			para que se le aplique a cada elemento del hashmap.			*/			cellHashMap.actionsForElements(setImageToMapCell);						/* 				Una vez formado el mapa con las imagenes de forma dinamica, se crea 12 imágenes que cubre toda la extensión del mapa, 				para que al escalarlo o cambiarlo de tamaño no haya problemas de visualizacion ni perdida de calidad.			*/			//buildMapWithTwelveImage();						// Adicionando las animaciones asociadas a las celdas			cellHashMap.actionsForElements(setMCToMapCell);						// Posicionando pins de otros usuarios que han vivido la experiencia			for(var i:int = 0; i < DataModel.getInstance().settings.locationList.length; i++) 			{				// Obteniendo localizacion				var locationVO:LocationVO = DataModel.getInstance().settings.locationList[i] as LocationVO;								// Creo una clase correspondiente al objeto en la biblioteca del swf				var Pin:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition("Pin") as Class;								// Creando PIN asociado con la cancion seleccionada por el usuario				var pin:MovieClip = new Pin();				pin.mouseChildren = false;				pin.useHandCursor = true;				pin.buttonMode = true;				pin.gotoAndStop(locationVO.trackIndex);				pin.x = locationVO.localX;				pin.y = locationVO.localY;								// Creo una clase correspondiente al objeto en la biblioteca del swf				var MessageMarker:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageDefaultMarker") as Class;				/*					Cada pin tendrá un marcador asociado, que corresponde con los datos del usuario que ha vivido una experiencia vetusta.  					Existe un objeto [Location class], que tiene propiedades que relaciona todos los datos y objetos suficientes a cada usuario.					A cada pin se le asignarán eventos de ROLL_OVER y ROLL_OUT para mostrar el marcador con los datos del usuario conrrespondiente				*/ 				var location:Location = new Location(stage, highResolutionMap);				location.vo = locationVO;				location.pin = pin;				location.messageMarker = new MessageMarker();								// Adicionando localizacion al administrador de localizaciones				var locationKey:String = LocationManager.getInstance().add(location);				trace("locationKey: ", locationKey);								// Adjuntando llave (key) de la localizacion en el mapa de localizaciones (LocationManager) para poder acceder a ella desde el pin				pin.locationKey = locationKey;				location.messageMarker.locationKey = locationKey								// Configurando detectores de eventos 				pin.addEventListener(MouseEvent.ROLL_OVER, onPinMouseOverHandler, false, 0, true);								// Adicionando pin en el mapa de forma local				highResolutionMap.addChild(pin);			}						// Eliminando mapa de la lista de objetos a reposicionar cuando se redimensione el stage, pero no de la pantalla			StageManager.getInstance().removeObject(DataModel.COMPONENT_HIGH_RESOLUTION_MAP_HASH, false);						// Configurando componente destino de acciones de zoom			(toolBar as MovieClip).zoom.zoomTarget = highResolutionMap;						// Cambiando el mapa de alta resolucion a la mitad de la escala			highResolutionMap.scaleX *= .25;			highResolutionMap.scaleY *= .25;						// Actualizando el porcentaje de escala actual			actualPercentageScaleMap = 0.75;						// Posicionando los pajaros			birdsAnimation.x = stage.stageWidth + 50;			birdsAnimation.y = stage.stageHeight + 50;			stage.addChild(birdsAnimation);						// Animacion de los pajaros volando			Tweener.addTween(birdsAnimation, {scaleX:.5, time:5, transition:"linear"});			Tweener.addTween(birdsAnimation, {scaleY:.5, time:5, transition:"linear"});			Tweener.addTween(birdsAnimation, {x:stage.x - birdsAnimation.width - 50, y:stage.y - birdsAnimation.height - 50, time:15, delay:.5, transition:"easeOutExpo", onComplete: removeBirdAnimation});						// Haciendo transicion entre el mapa de baja resolucion y el mapa de alta			Tweener.addTween(highResolutionMap, {scaleX:.75, time:4, delay:.5, transition:"linear", onComplete: moveMapToMessagePoint});			Tweener.addTween(highResolutionMap, {scaleY:.75, time:4, delay:.5, transition:"linear"});						// Configurando detectores de eventos respectivos al mapa			highResolutionMap.addEventListener(MouseEvent.MOUSE_DOWN, onMapDragHandler);			highResolutionMap.addEventListener(MouseEvent.MOUSE_UP, onMapDropHandler);			highResolutionMap.addEventListener(MouseEvent.MOUSE_MOVE, onMapMoveHandler);						// Eliminando el mapa a baja resolucion			StageManager.getInstance().removeObject(DataModel.COMPONENT_LOW_RESOLUTION_MAP_HASH);			}				private function removeBirdAnimation():void 		{			stage.removeChild(birdsAnimation);			birdsAnimation = null;			trace("*/*/*/*/*/*/*/*/*/ - Animacion de los pajaros eliminada...");		}				/**		 * @method		 * Construye el mismo mapa de alta resolucion, pero a partir de 12 screen shots dinamicos del mapa formado por 144 imagenes.		 */ 		private function buildMapWithTwelveImages():void		{			// Declarando variables auxiliares			var imageList:Array = new Array();			var pointList:Array = new Array();						// Inicializando lista de puntos de forma secuencial de donde partira cada pantallazo.			pointList.push(new Point(-(6 * DataModel.MAP_CELL_WIDTH), -(6 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 0			pointList.push(new Point(-(3 * DataModel.MAP_CELL_WIDTH), -(6 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 1			pointList.push(new Point(0, -(6 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 2			pointList.push(new Point((3 * DataModel.MAP_CELL_WIDTH), -(6 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 3						pointList.push(new Point(-(6 * DataModel.MAP_CELL_WIDTH), -(3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 4			pointList.push(new Point(-(3 * DataModel.MAP_CELL_WIDTH), -(3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 5			pointList.push(new Point(0, -(3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 6			pointList.push(new Point((3 * DataModel.MAP_CELL_WIDTH), -(3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 7						pointList.push(new Point(-(6 * DataModel.MAP_CELL_WIDTH), 0));	// PUNTO CON INDICE 8			pointList.push(new Point(-(3 * DataModel.MAP_CELL_WIDTH), 0));	// PUNTO CON INDICE 9			pointList.push(new Point(0, 0));	// PUNTO CON INDICE 10			pointList.push(new Point((3 * DataModel.MAP_CELL_WIDTH), 0));	// PUNTO CON INDICE 11						pointList.push(new Point(-(6 * DataModel.MAP_CELL_WIDTH), (3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 12			pointList.push(new Point(-(3 * DataModel.MAP_CELL_WIDTH), (3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 13			pointList.push(new Point(0, (3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 14			pointList.push(new Point((3 * DataModel.MAP_CELL_WIDTH), (3 * DataModel.MAP_CELL_HEIGHT)));	// PUNTO CON INDICE 15						// Trazas			trace("Puntos de bloques: ", pointList.toString());						// Lo primero capturar las 12 imagenes y guardarlas en una lista consecutiva			for(var i:uint = 0; i < pointList.length; i++)			{				var tempBitmapData:BitmapData = new BitmapData (3 * DataModel.MAP_CELL_WIDTH, 3 * DataModel.MAP_CELL_HEIGHT);				tempBitmapData.draw(highResolutionMap, null, null, null, new Rectangle((pointList[i] as Point).x, (pointList[i] as Point).y, 3 * DataModel.MAP_CELL_WIDTH, 3 * DataModel.MAP_CELL_HEIGHT), true);				var tempBitmap = new Bitmap(tempBitmapData);				//tempBitmap.x = (pointList[i] as Point).x;				//tempBitmap.y = (pointList[i] as Point).y;				tempBitmap.x = 0;				tempBitmap.y = 0;				imageList.push(tempBitmap);			}						// Luego eliminar de la lista de visualizacion del map todas las imagenes pequeñas			while(highResolutionMap.numChildren > 0)				highResolutionMap.removeChildAt(0);						// Y por ultimo adicionar las nuevas imagenes (mas grandes) al mismo objeto visual (mapa alta resolucion), de esta forma se pretende reducir la cantidad de ensamblajes de 144 a 16			for(var k:uint = 0; k < imageList.length; k++) 			{				var btn:Button = new Button();				btn.name = "btn_" + k;				btn.label = "View image " + k;				btn.x = k * btn.width + 5;				stage.addChild(btn);				btn.addEventListener(MouseEvent.CLICK, function(evt:MouseEvent):void{					var indexOf:int = (evt.target as Button).name.lastIndexOf("_");					var index:uint = uint((evt.target as Button).name.substr(indexOf + 1));					highResolutionMap.addChild(imageList[index] as Bitmap);				});														trace("imageList[" + k + "].x; imageList[" + k + "].y: ", new Point((imageList[k] as Bitmap).x, (imageList[k] as Bitmap).y));				highResolutionMap.addChild(imageList[k] as Bitmap);			}						/*			tempBitmapData = new BitmapData (3 * DataModel.MAP_CELL_WIDTH, 3 * DataModel.MAP_CELL_HEIGHT);			tempBitmapData.draw(highResolutionMap, null, null, null, new Rectangle(0, 0, 3 * DataModel.MAP_CELL_WIDTH, 4 * DataModel.MAP_CELL_HEIGHT), true);			tempBitmap = new Bitmap(tempBitmapData);			var mc:MovieClip = new MovieClip();			mc.addChild(tempBitmap);			stage.addChild(mc);			*/		}				private function onPinMouseOverHandler(evt:MouseEvent):void		{			if(!isLockMapControl) 			{				trace("MOUSE_OVER on pin...");								// Recuperando localizacion				var locationKey:String = (evt.currentTarget as MovieClip).locationKey;				var location:Location = LocationManager.getInstance().locationWithKey(locationKey) as Location;								// Eliminando detector de evento ROLL_OVER				location.pin.removeEventListener(MouseEvent.ROLL_OVER, onPinMouseOverHandler);									// Definiendo variable para el calculo en tiempo real de las coordenadas globales a partir de las locales				var localPoint:Point = new Point(location.vo.localX, location.vo.localY);				var globalPoint:Point;								// Calculando el punto global, en tiempo real, segun las coordenadas locales				globalPoint = highResolutionMap.localToGlobal(localPoint);								// Verificando la posicion del marcador en la pantalla para sacar el mensaje del usuario de una forma u otra				var MessageMarker:Class;				if(globalPoint.x < stage.stageWidth / 2)	// MITAD IZQUIERDA				{					if(globalPoint.y < stage.stageHeight / 2)	// MITAD SUPERIOR					{						MessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageTopLeftMarker") as Class;					}					else	// MITAD INFERIOR					{						MessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageBottomLeftMarker") as Class;					}				}				else 	// MITAD DERECHA				{					if(globalPoint.y < stage.stageHeight / 2)	// MITAD SUPERIOR					{						MessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageTopRightMarker") as Class;					}					else	// MITAD INFERIOR					{						MessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageBottomRightMarker") as Class;					}				}								// Actualizando forma del marcador para mostrar el mensaje				var newMessageMarker:MovieClip = new MessageMarker();				newMessageMarker.locationKey = location.messageMarker.locationKey				location.messageMarker = newMessageMarker;									// Adicionando detector de evento para cerrar mensaje				(location.messageMarker.closeButton as SimpleButton).addEventListener(MouseEvent.CLICK, onPinCloseButtonHandler);									// Mostrando mensaje				location.showMessageMarker(stage);								// Desactivando el control de desplazamiento del mapa				isLockMapControl = true;			}		}				private function onPinCloseButtonHandler(evt:MouseEvent):void		{			trace("Closing user message...");						// Recuperando localizacion			var locationKey:String = (evt.target.parent as MovieClip).locationKey;			var location:Location = LocationManager.getInstance().locationWithKey(locationKey) as Location;						// Eliminando detector de evento ROLL_OVER			(location.messageMarker.closeButton as SimpleButton).removeEventListener(MouseEvent.CLICK, onPinCloseButtonHandler);						// Configurando detectores de eventos 			location.pin.addEventListener(MouseEvent.ROLL_OVER, onPinMouseOverHandler, false, 0, true);						// Cerrando mensaje del usuario			location.closeMessageMarker();						// Activando el control de desplazamiento del mapa			isLockMapControl = false;		}				private function connectWithFacebook(evt:MouseEvent):void		{			trace("VetustaMusicExperienceAppController->connectWithFacebook()");			trace("DataModel.FACEBOOK_LOCAL_USER_ACTIVE: ", DataModel.FACEBOOK_LOCAL_USER_ACTIVE);			if(!DataModel.FACEBOOK_LOCAL_USER_ACTIVE) {				debug("Ejecutando funcion en ExternalInterface");				ExternalInterface.call("FBlogin");			} else {				debug("Ejecutando funcion FBloggedIn en local");				FBloggedIn(DataModel.FACEBOOK_USER_TOKEN);			}						// Visibilizando indicador de actividad			(wizardModalWindow.activityIndicatorWizardModalWindow as MovieClip).visible = true;						// Inhabilitando boton de Facebook Connect			(wizardModalWindow.fbConnectButton as SimpleButton).enabled = false;			(wizardModalWindow.fbConnectButton as SimpleButton).useHandCursor = false;			(wizardModalWindow.fbConnectButton as SimpleButton).removeEventListener(MouseEvent.CLICK, connectWithFacebook);		}				private function FBloggedIn(token:String):void		{			debug("VetustaMusicExperienceAppController->FBloggedIn()");			debug("Flash: token=" + token);						// Guardando TOKEN para futuras peticiones			fbUserToken = token;						// Enviando datos al servicio PHP de registro			trace("Enviando datos al servicio PHP para obtener datos de FB del usuario...");						// Enviando variable al servicio PHP			var urlVars:URLVariables = new URLVariables();			if(fbUserToken) 				urlVars.access_token = fbUserToken;						debug("urlVars.access_token: " + urlVars.access_token);						// Opciones del servicio PHP			var urlPHPServiceRequest:URLRequest = new URLRequest(DataModel.URL_GET_USER_INFO_PHP_SERVICE);			urlPHPServiceRequest.method = URLRequestMethod.POST;			urlPHPServiceRequest.data = urlVars;						// Enviando datos al servicio			var urlLoaderPHPService:URLLoader = new URLLoader();			urlLoaderPHPService.dataFormat = URLLoaderDataFormat.VARIABLES;			urlLoaderPHPService.addEventListener(Event.COMPLETE, onUserInfoPHPServiceComplete);			urlLoaderPHPService.addEventListener(IOErrorEvent.IO_ERROR, onSendPHPServiceError);			urlLoaderPHPService.load(urlPHPServiceRequest);					}				private function onUserInfoPHPServiceComplete(evt:Event):void		{			debug("evt.target.toString(): " + evt.target.toString());					debug("evt.target.data: " + evt.target.data);						var loader:URLLoader = URLLoader(evt.target);			fbUserName = loader.data.name;			fbUrlUserImage = loader.data.image;						debug("Respuesta del servidor [fbUserName]: " + fbUserName);			debug("Respuesta del servidor [fbUrlUserImage]: " + fbUrlUserImage);						try			{					loadXMLLocations();			}			catch(e:Error)			{				debug(e.toString());				throw new Error(e.toString());			}		}				private function loadXMLLocations():void		{			// Enviando datos al servicio PHP de registro			debug("Cargando localizaciones...");						// Opciones del servicio PHP			var urlPHPServiceRequest:URLRequest = new URLRequest(DataModel.URL_GET_LOCATIONS_PHP_SERVICE);			urlPHPServiceRequest.method = URLRequestMethod.POST;						// Enviando datos al servicio			var urlLoaderPHPService:URLLoader = new URLLoader();			urlLoaderPHPService.addEventListener(Event.COMPLETE, onLocationsPHPServiceComplete);			urlLoaderPHPService.addEventListener(IOErrorEvent.IO_ERROR, onSendPHPServiceError);			urlLoaderPHPService.load(urlPHPServiceRequest);		}				/**		 * @event		 * Ejecuta acciones una vez se retorna la respuesta desde el servidor		 */		private function onLocationsPHPServiceComplete(evt:Event):void					{			trace("VetustaMusicExperienceAppController->onLocationsPHPServiceComplete()");						try			{				// Recuperando XML de las localizaciones 				var locationsXML:XML = new XML(evt.target.data);								// Parseando XML				DataModel.getInstance().settings.locationList = XMLParser.parseLocationsXML(locationsXML);				trace("DataModel.getInstance().settings.locationList.length: ", DataModel.getInstance().settings.locationList.length);								// Cargando imagen				bulkLoader.add(new URLRequest(fbUrlUserImage), {id:fbUrlUserImage});				bulkLoader.addEventListener(BulkLoader.COMPLETE, onLoadFBUserImageHandler);				bulkLoader.addEventListener(BulkLoader.ERROR, onErrorHandler);				bulkLoader.start();							} catch(e:Error) { throw e; }					}				private function onLoadFBUserImageHandler(evt:Event):void 		{			debug("User image loaded...");						// Eliminando detectores de eventos			bulkLoader.addEventListener(BulkLoader.COMPLETE, onLoadFBUserImageHandler);			bulkLoader.addEventListener(BulkLoader.ERROR, onErrorHandler);						// Invisibilizando boton de Facebook Connect			(wizardModalWindow.fbConnectButton as SimpleButton).visible = false;						// Obteniendo imagen del usuario			fbUserImage = bulkLoader.getBitmap(fbUrlUserImage);						// Deteniendo indicador de actividad			(wizardModalWindow.activityIndicatorWizardModalWindow as MovieClip).visible = false;						// Pasando a proxima pantalla del wizard			wizardModalWindow.nextFrame();		}				public function onUserAcceptMessageDialogHandler(evt:MouseEvent):void		{			trace("VetustaMusicExperienceAppController->onUserAcceptMessageDialogHandler()");		}					private function onSendPHPServiceError(evt:Event):void {			trace("Respuesta del servicio PHP: " + evt.toString());			debug("Respuesta del servicio PHP: " + evt.toString());						// Mostrando mensaje de error			actualMarker.errorMessage_txt.visible = true;						// Activando detectores de eventos e inhabilitando boton de envio			(actualMarker.sendButton as SimpleButton).addEventListener(MouseEvent.CLICK, sendUserMessageToServer);			(actualMarker.sendButton as SimpleButton).enabled = true;			(actualMarker.sendButton as SimpleButton).useHandCursor = true;						// Invisivilizando indicador de actividad			(actualMarker.sendMessageActivityIndicator as MovieClip).visible = false;		}				private function getNumberListAt(value:uint):Array		{			// Inicializando variables 			var numbersForTranslate:Array;						// Obteniendo listado de numeros asociados a los segundos del tema seleccionado			var numberList:Array = DataModel.getInstance().matrixOfNumberForSounds[playingSoundIndex];			trace("Numbers for selected track [index=" + playingSoundIndex + "]: ", numberList.toString());						// Verificando que el segundo de comenzar experiencia deje rango de 6 valores			if(numberList.length - value > 6) {				numbersForTranslate = numberList.slice(value, value + DataModel.TOTAL_NUMBERS_FOR_TRANSLATE_IN_CELL_ID);			} else {				numbersForTranslate = numberList.slice(numberList.length - DataModel.TOTAL_NUMBERS_FOR_TRANSLATE_IN_CELL_ID);			}							return numbersForTranslate;		}				private function translateNumbersInCellId(numberList:Array):String		{			trace("Lista de numeros recibidos: ", numberList.toString());					// Inicializando valriables			var cellId:String = "";			var actualChar:String = "";						for (var i:int = 0; i < numberList.length; i++) 			{				var number:uint = numberList[i];				switch(i) 				{					case 0:						actualChar = (DataModel.LETTERS_BLOCK_LIST[number % 3]).toString();						break;										case 1:						actualChar = (number % 3).toString();						break;										case 2:						cellId += "-";					case 3:					case 4:					case 5:						actualChar = (number % 2).toString();						break;				} 									// Concatenando ID de celda con el caracter actual				cellId += actualChar;			}						return cellId;		}				private function randomPointInCell(minPoint:Point, maxPoint:Point):Point		{			var randomPoint:Point = new Point();			randomPoint.x = NumberUtils.randomNumber(minPoint.x, maxPoint.x);			randomPoint.y = NumberUtils.randomNumber(minPoint.y, maxPoint.y);			return randomPoint;		}				private function moveMapToMessagePoint():void		{			// TRADUCIENDO NUMEROS EN ID DE CELDA						// Deteniendo el temporizador que cuenta el tiempo de reproduccion de la cancion hasta comenzar experiencia			soundTimer.stop();			trace("Cantidad de segundos de reproduccion:", soundSecondCounter);						// Obteniendo el listado de numeros a traducir en ID de celda			var numbersForTranslate:Array = getNumberListAt(soundSecondCounter);			trace("numbersForTranslate: ", numbersForTranslate);						// Traduciendo numeros en ID de celda			//var cellId:String = "C2-1111";			var cellId:String = translateNumbersInCellId(numbersForTranslate);			trace("cellId: ", cellId);						// Obteniendo celda con el mismo ID			actualCellForExperience = cellHashMap.getValue(cellId);			trace("ID de celda obtenida: ", actualCellForExperience.idCell);			trace("actualCellForExperience.offsetX: ", actualCellForExperience.offsetX);			trace("actualCellForExperience.offsetY: ", actualCellForExperience.offsetY);						// Obteniendo valor aleatorio para posicionar el marcador en la celda			var minPoint:Point = new Point(actualCellForExperience.offsetX, actualCellForExperience.offsetY);			var maxPoint:Point = new Point(minPoint.x + actualCellForExperience.image.width, minPoint.y + actualCellForExperience.image.height);			actualRandomPointToMarker = randomPointInCell(minPoint, maxPoint);			trace("actualRandomPointToMarker coordinates:", actualRandomPointToMarker);						// Obteniendo posicion de celda homologa pero en el cuadrante contrario			var reflectionCellPoint:Point = new Point(-actualRandomPointToMarker.x, -actualRandomPointToMarker.y);			trace("reflectionCellPoint: ", reflectionCellPoint);						trace("actualCellForExperience.image.width: ", actualCellForExperience.image.width);			trace("actualCellForExperience.image.height: ", actualCellForExperience.image.height);						// Conviertiendo cordenadas locales del punto homologo al centro de la celda real, pero en el cuadrante contrario			var globalCenterDestinationPoint:Point = highResolutionMap.localToGlobal(reflectionCellPoint);						trace("globalCenterDestinationPoint: ", globalCenterDestinationPoint);						// Moviendo mapa a la coordenada calculada			this.addEventListener(Event.ENTER_FRAME, checkBoundsCollition);				Tweener.addTween(highResolutionMap, {x:globalCenterDestinationPoint.x, y:globalCenterDestinationPoint.y, time:10, transition:"linear", onComplete:removeEnterFrameForBoundsCollition});		}				private function updateMapWithZoom(evt:EventComplex):void		{				trace("evt.data.zoomValue: ", evt.data.zoomValue);			trace("actualPercentageScaleMap: ", actualPercentageScaleMap);						var scale:Number			if(Number(evt.data.zoomValue) != actualPercentageScaleMap)			{				trace(Math.abs(actualPercentageScaleMap - Number(evt.data.zoomValue)));				scale = 1.0 - Math.abs(actualPercentageScaleMap - Number(evt.data.zoomValue));								this.addEventListener(Event.ENTER_FRAME, checkBoundsCollition);					if(Number(evt.data.zoomValue) < actualPercentageScaleMap)				{					Tweener.addTween(highResolutionMap, {scaleX:highResolutionMap.scaleX * scale, time:1, transition:"linear", onComplete:removeEnterFrameForBoundsCollition});					Tweener.addTween(highResolutionMap, {scaleY:highResolutionMap.scaleY * scale, time:1, transition:"linear"});				}				else				{					Tweener.addTween(highResolutionMap, {scaleX:highResolutionMap.scaleX / scale, time:1, transition:"linear", onComplete: removeEnterFrameForBoundsCollition});					Tweener.addTween(highResolutionMap, {scaleY:highResolutionMap.scaleY / scale, time:1, transition:"linear"});				}								// Actualizando porcentaje de scala del mapa				actualPercentageScaleMap = Number(evt.data.zoomValue);			}		}				private function removeEnterFrameForBoundsCollition(isMapOutOfBounds:Boolean = false):void 		{			// Eliminando detectores de eventos			this.removeEventListener(Event.ENTER_FRAME, checkBoundsCollition);			//highResolutionMap.cacheAsBitmap = true;						/* 			Una vez formado el mapa con las imagenes de forma dinamica, se crean 12 imágenes que cubren toda la extensión del mapa, 			para que al escalarlo o cambiarlo de tamaño no haya problemas de visualizacion ni perdida de calidad.			*/			//buildMapWithTwelveImages();						// Definiendo clase para tipo de marcador a utilizar			var WriteMessageMarker:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageDefaultMarker") as Class;			var PinSectorArea:Class;			var pinSectorArea:MovieClip;			var distance:Number;						if(isMapOutOfBounds)			{				trace("Calculando nueva posicion del marcador, no es posible llevar el punto calculado para el marcador hasta el centro de la pantalla.");								// Obteniendo posicion local de la celda obtenida para la experiencia				localPoint = new Point(actualCellForExperience.offsetX, actualCellForExperience.offsetY);								// Conviertiendo coordenadas locales de la celda a globales				globalPoint = highResolutionMap.localToGlobal(localPoint);				trace("globalPoint: ", globalPoint);								// Definiendo variables locales auxiliares				var minX:Number;				var minY:Number;				var maxX:Number;				var maxY:Number;								if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_TOP)		// LIMITE SUPERIOR				{					trace("El mapa ha salido por el limite SUPERIOR");					trace("Limite: ", mapOutOfBoundsType);										// Verficando cual de las tres posible posiciones de la celda elegida es la actual					if(globalPoint.x <= stage.x && globalPoint.y <= stage.y)		// La celda se sale del stage por la IZQUIERDA SUPERIOR					{						trace("La celda se ha salido del stage por la IZQUIERDA SUPERIOR");												// Definiendo sector de coordenadas						minX = stage.x + 20;						minY = stage.y + 20;						maxX = minX + DataModel.MAP_CELL_WIDTH - Math.abs(globalPoint.x) - 20;						maxY = minY + DataModel.MAP_CELL_HEIGHT - Math.abs(globalPoint.y) - 20;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopLeftMarker") as Class;					}					else if(globalPoint.x + DataModel.MAP_CELL_WIDTH >= stage.stageWidth && globalPoint.y <= stage.y)	// La celda se sale del stage por la DERECHA					{						trace("La celda se ha salido del stage por la DERECHA SUPERIOR");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = stage.y + 20;						maxX = stage.stageWidth - 20;						maxY = minY + DataModel.MAP_CELL_HEIGHT - Math.abs(globalPoint.y) - 20;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopRightMarker") as Class;					}					else	// La celda no se sale del stage, es visible su margen DERECHO e IZQUIERDO					{						trace("La celda no se ha salido del stage, es visible su margen DERECHO e IZQUIERDO");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = stage.y + 20;						maxX = minX + DataModel.MAP_CELL_WIDTH;						maxY = minY + DataModel.MAP_CELL_HEIGHT - Math.abs(globalPoint.y) - 20;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						if(globalPoint.x <= stage.stageHeight) 							WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopLeftMarker") as Class;						else 							WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopRightMarker") as Class;					}				}				else if (mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_BOTTOM)		// LIMITE INFERIOR				{					trace("El mapa ha salido por el limite INFERIOR");					trace("Limite: ", mapOutOfBoundsType);										// Verficando cual de las tres posible posiciones de la celda elegida es la actual					if(globalPoint.x <= stage.x)		// La celda se sale del stage por la IZQUIERDA					{						trace("La celda se ha salido del stage por la IZQUIERDA INFERIOR");												// Definiendo sector de coordenadas						minX = stage.x + 20;						minY = globalPoint.y;						maxX = minX + (DataModel.MAP_CELL_WIDTH - Math.abs(globalPoint.x) - 20);						maxY = stage.stageHeight - 60;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomLeftMarker") as Class;					}					else if(globalPoint.x + DataModel.MAP_CELL_WIDTH >= stage.stageWidth)	// La celda se sale del stage por la DERECHA					{						trace("La celda se ha salido del stage por la DERECHA INFERIOR");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = globalPoint.y;						maxX = stage.stageWidth - 20;						maxY = stage.stageHeight - 60;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomRightMarker") as Class;					}					else	// La celda no se sale del stage, es visible su margen DERECHO e IZQUIERDO					{						trace("La celda no se ha salido del stage, es visible su margen DERECHO e IZQUIERDO");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = globalPoint.y; 						maxX = minX + DataModel.MAP_CELL_WIDTH;						maxY = stage.stageHeight - 60;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						if(globalPoint.x <= stage.stageHeight) 							WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomLeftMarker") as Class;						else 							WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomRightMarker") as Class;					}				}				else if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_LEFT)		// LIMITE IZQUIERDO				{					trace("El mapa ha salido por el limite IZQUIERDO");					trace("Limite: ", mapOutOfBoundsType);										// Verficando cual de las tres posible posiciones de la celda elegida es la actual					if(globalPoint.x <= stage.x && globalPoint.y <= stage.y)		// La celda se sale del stage por la IZQUIERDA SUPERIOR					{						trace("La celda se ha salido del stage por la IZQUIERDA SUPERIOR");												// Definiendo sector de coordenadas						minX = stage.x + 20;						minY = stage.y + 20;						maxX = minX + (DataModel.MAP_CELL_WIDTH - Math.abs(globalPoint.x) - 20);						maxY = minY + (DataModel.MAP_CELL_HEIGHT - Math.abs(globalPoint.y) - 20);												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopLeftMarker") as Class;					}					else if(globalPoint.x <= stage.x && globalPoint.y + DataModel.MAP_CELL_HEIGHT >= stage.stageHeight)	// La celda se ha salido del stage por la IZQUIERDA INFERIOR					{						trace("La celda se ha salido del stage por la IZQUIERDA INFERIOR");												// Definiendo sector de coordenadas						minX = stage.x + 20;						minY = globalPoint.y;						maxX = minX + (DataModel.MAP_CELL_WIDTH - Math.abs(globalPoint.x) - 20);						maxY = stage.stageHeight - 60;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomLeftMarker") as Class;					}					else	// La celda no se sale del stage, es visible su margen SUPERIOR e INFERIOR					{						trace("La celda no se ha salido del stage, es visible su margen SUPERIOR e INFERIOR");												// Definiendo sector de coordenadas						minX = stage.x + 20;						minY = globalPoint.y;						maxX = minX + (DataModel.MAP_CELL_WIDTH - Math.abs(globalPoint.x) - 20);						maxY = globalPoint.y + DataModel.MAP_CELL_HEIGHT;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopLeftMarker") as Class;					}					}				else if (mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_RIGHT)		// LIMITE DERECHO				{					trace("El mapa ha salido por el limite DERECHO");					trace("Limite: ", mapOutOfBoundsType);										// Verficando cual de las tres posible posiciones de la celda elegida es la actual					if(globalPoint.y <= stage.y)	// La celda se sale del stage por la DERECHA SUPERIOR					{						trace("La celda se ha salido del stage por la DERECHA SUPERIOR");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = stage.y + 20;						maxX = stage.stageWidth - 20;						maxY = minY + DataModel.MAP_CELL_HEIGHT - Math.abs(globalPoint.y) - 20;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageTopRightMarker") as Class;					}					else if(globalPoint.y + DataModel.MAP_CELL_HEIGHT >= stage.stageHeight)	// La celda se sale del stage por la DERECHA INFERIOR					{						trace("La celda se ha salido del stage por la DERECHA INFERIOR");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = globalPoint.y;						maxX = stage.stageWidth - 20;						maxY = stage.stageHeight - 60;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomRightMarker") as Class;					}					else	// La celda no se sale del stage, es visible su margen SUPERIOR e INFERIOR					{						trace("La celda no se ha salido del stage, es visible su margen SUPERIOR e INFERIOR");												// Definiendo sector de coordenadas						minX = globalPoint.x;						minY = globalPoint.y;						maxX = stage.stageWidth - 20;						maxY = globalPoint.y + DataModel.MAP_CELL_HEIGHT;												// Inicializando clase correspondiente al objeto en la biblioteca del swf						WriteMessageMarker = mainMovieClip.loaderInfo.applicationDomain.getDefinition("WriteMessageBottomRightMarker") as Class;					}				}								/*				trace("minX: ", minX);				trace("minY: ", minY);				trace("maxX: ", maxX);				trace("maxY: ", maxY);								// Inicializando clase correspondiente al objeto en la biblioteca del swf				PinSectorArea = mainMovieClip.loaderInfo.applicationDomain.getDefinition("PinSectorArea") as Class;				pinSectorArea = new PinSectorArea();				pinSectorArea.x = highResolutionMap.globalToLocal(new Point(minX, minY)).x;				pinSectorArea.y = highResolutionMap.globalToLocal(new Point(minX, minY)).y;				pinSectorArea.width = maxX - minX;				pinSectorArea.height = maxY - minY;				pinSectorArea.alpha = .5;				highResolutionMap.addChild(pinSectorArea);								trace("Pin sector area added....");				trace("pinSectorArea.x: ", pinSectorArea.x);				trace("pinSectorArea.y: ", pinSectorArea.y);				trace("pinSectorArea.width: ", pinSectorArea.width);				trace("pinSectorArea.height: ", pinSectorArea.height);				//*/								// Creando puntos con coordenadas maxima para calculo aleatorio				var minPoint:Point = new Point(minX, minY);				var maxPoint:Point = new Point(maxX, maxY);								// Obteniendo punto aleatorio dentro del sector de coordenadas permitido				actualRandomPointToMarker = randomPointInCell(minPoint, maxPoint);				trace("NEW actualRandomPointToMarker coordinates:", actualRandomPointToMarker);								// Actualizando puntos de anclaje de objetos visuales				localPoint = highResolutionMap.globalToLocal(actualRandomPointToMarker);				globalPoint = actualRandomPointToMarker;			}			else			{				// Actualizando puntos de anclaje de objetos visuales				localPoint = actualRandomPointToMarker;				globalPoint = highResolutionMap.localToGlobal(actualRandomPointToMarker);			}						// trazas			trace("localPoint: ", localPoint);			trace("globalPoint: ", globalPoint);						// Creo un objetos de tipo RedMarker			actualMarker = new WriteMessageMarker();			actualMarker.x = globalPoint.x;			actualMarker.y = -10;						// Invisibilizando indicador de actividad			(actualMarker.sendMessageActivityIndicator as MovieClip).visible = false;						// Invisibilizando mensaje de error			actualMarker.errorMessage_txt.visible = false;						if(fbUrlUserImage != null) 			{				// Configurando marcador con las propiedades del usuario				(actualMarker.image as MovieClip).addChild(fbUserImage);				actualMarker.name_dtxt.text = fbUserName;				actualMarker.world_dtxt.text = DataModel.getInstance().worldHashmap.getValue(actualCellForExperience.idCell);								// Configurando detectores de eventos				(actualMarker.closeButton as SimpleButton).addEventListener(MouseEvent.CLICK, closeMarkerUserMessage);				(actualMarker.sendButton as SimpleButton).addEventListener(MouseEvent.CLICK, sendUserMessageToServer);								// Deteniendo indicador de actividad de carga de la imagen				(actualMarker.activityIndicator as MovieClip).visible = false;			} 			else 			{				// Iniciando indicador de actividad de carga de la imagen				(actualMarker.activityIndicator as MovieClip).visible = true;			}						// Configurando PIN para que coincida con la posicion de la experiencia del usuario			actualPin = toolBar.playerComponent.pinForUserTrackSelected;			actualPin.x = localPoint.x;			actualPin.y = localPoint.y;						// Adicionando pin en el mapa de forma local			highResolutionMap.addChild(actualPin);			trace("Pin added to map...");						// Adicionando marcador al escenario			stage.addChild(actualMarker);			trace("Marker added to stage...");						// Inhabilitando control del usuario sobre el mapa			isLockMapControl = true;						// Animando marcador			Tweener.addTween(actualMarker, {y:globalPoint.y, time:0.3, transition:"easeOutSine"});		}				private function closeMarkerUserMessage(evt:MouseEvent = null, removePin:Boolean = true):void 		{			// Eliminando detectores de eventos del marcador			(actualMarker.closeButton as SimpleButton).removeEventListener(MouseEvent.CLICK, closeMarkerUserMessage);						// Eliminando marcador del stage			stage.removeChild(actualMarker);						// Eliminando pin del mapa			if(removePin) 				highResolutionMap.removeChild(actualPin);						// Habilitando control del usuario sobre el mapa			isLockMapControl = false;			isMapMoveCancel = false;						// Habilitando controles de la barra de herramientas			toolBar.lockLayer.visible = false;						// Mostrando barra de herramientas			toolBar.y += toolBar.height;			Tweener.addTween(toolBar, {y:toolBar.y - toolBar.height, time:1, transition:"easeOutSine"}); 			Tweener.addTween(toolBar, {alpha:1, time:1, transition:"easeOutSine"}); 		}				private function sendUserMessageToServer(evt:MouseEvent):void 		{			if(actualMarker.message_dtxt.text != "")			{					// Invisibilizando mensaje de error				actualMarker.errorMessage_txt.visible = false;								// Eliminando detectores de eventos e inhabilitando boton de envio				(actualMarker.sendButton as SimpleButton).removeEventListener(MouseEvent.CLICK, sendUserMessageToServer);				(actualMarker.sendButton as SimpleButton).enabled = false;				(actualMarker.sendButton as SimpleButton).useHandCursor = false;								// Mostrando indicador de actividad				(actualMarker.sendMessageActivityIndicator as MovieClip).visible = true;								// Enviando datos al servicio PHP de registro				debug("Enviando mensaje de usuario al servidor...");								// Enviando variable al servicio PHP				var urlVars:URLVariables = new URLVariables();				if(DataModel.getInstance().flashvars && !DataModel.FACEBOOK_LOCAL_USER_ACTIVE) {					urlVars.access_token = fbUserToken;					debug("FLASHVARS - urlVars.access_token: "+ urlVars.access_token);				} else { 					urlVars.access_token = DataModel.FACEBOOK_USER_TOKEN;					debug("DATAMODEL - urlVars.access_token: "+ urlVars.access_token);				}								// Haciendo tratamiento de cadenas para sacar el nombre de la imagen				var index:int = fbUrlUserImage.lastIndexOf("/");				var imageName:String = fbUrlUserImage.substr(index + 1);				debug("imageName: " + imageName);								// Adicionando las demas variables que espera el servicio				urlVars.user_name = fbUserName;		        urlVars.user_image = imageName;		        urlVars.text = actualMarker.message_dtxt.text;		        urlVars.zone = actualCellForExperience.idCell;				urlVars.world = actualMarker.world_dtxt.text;		        urlVars.song = (toolBar.playerComponent as MovieClip).trackIndexInDiscSelected;		        urlVars.global_x = globalPoint.x;		        urlVars.global_y = globalPoint.y		        urlVars.local_x = localPoint.x;		        urlVars.local_y = localPoint.y;						// Creando localizacion actual del pin				actualLocationVO = new LocationVO();				actualLocationVO.userName = fbUserName;				actualLocationVO.imageName = imageName; 				actualLocationVO.message = actualMarker.message_dtxt.text;				actualLocationVO.world = actualMarker.world_dtxt.text;				actualLocationVO.idCell = actualCellForExperience.idCell;				actualLocationVO.trackIndex = (toolBar.playerComponent as MovieClip).trackIndexInDiscSelected;				actualLocationVO.globalX = globalPoint.x;				actualLocationVO.globalY = globalPoint.y				actualLocationVO.localX = localPoint.x;				actualLocationVO.localY = localPoint.y;								// Opciones del servicio PHP				var urlPHPServiceRequest:URLRequest = new URLRequest(DataModel.URL_SAVE_LOCATION_PHP_SERVICE);				urlPHPServiceRequest.method = URLRequestMethod.POST;				urlPHPServiceRequest.data = urlVars;								// Enviando datos al servicio				var urlLoaderPHPService:URLLoader = new URLLoader();				urlLoaderPHPService.dataFormat = URLLoaderDataFormat.VARIABLES;				urlLoaderPHPService.addEventListener(Event.COMPLETE, onSendLocationPHPServiceComplete);				urlLoaderPHPService.addEventListener(IOErrorEvent.IO_ERROR, onSendPHPServiceError);				urlLoaderPHPService.load(urlPHPServiceRequest);			}			else {				debug("Message undefined...");								// TODO: Mostrar texto status para que indique que debe dejar un mensaje 			}		}				private function onSendLocationPHPServiceComplete(evt:Event):void		{			trace("VetustaMusicExperienceAppController->onSendLocationPHPServiceComplete");			trace("evt.target.toString(): " + evt.target.toString());			debug("evt.target.data: " + evt.target.data);						var loader:URLLoader = URLLoader(evt.target);			var success:Boolean = StringUtils.stringToBoolean(loader.data.succes);			var id:String = String(loader.data.id);			var fbuid:String = String(loader.data.fbuid);			debug("Respuesta del servidor [success]: " + success);						try			{				if(success)				{					// Invisibilizando el marcador con el mensaje					closeMarkerUserMessage(null, false);										// Actualizando objeto de localizacion con los datos obteniedos del servidor					actualLocationVO.id = uint(id);					actualLocationVO.fbuid = fbuid;										// Habilitando el pin para que muestre mensaje del usuario con ROLL_OVER					actualPin.mouseChildren = false;					actualPin.useHandCursor = true;					actualPin.buttonMode = true;										// Creo una clase correspondiente al objeto en la biblioteca del swf					var MessageMarker:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition("MessageDefaultMarker") as Class;										/*					Cada pin tendrá un marcador asociado, que corresponde con los datos del usuario que ha vivido una experiencia vetusta.  					Existe un objeto [Location class], que tiene propiedades que relaciona todos los datos y objetos suficientes a cada usuario.					A cada pin se le asignarán eventos de ROLL_OVER y ROLL_OUT para mostrar el marcador con los datos del usuario conrrespondiente					*/ 					var location:Location = new Location(stage, highResolutionMap);					location.vo = actualLocationVO;					location.pin = actualPin;					location.messageMarker = new MessageMarker();										// Adicionando localizacion al administrador de localizaciones					var locationKey:String = LocationManager.getInstance().add(location);					trace("locationKey: ", locationKey);										// Adjuntando llave (key) de la localizacion en el mapa de localizaciones (LocationManager) para poder acceder a ella desde el pin					actualPin.locationKey = locationKey;					location.messageMarker.locationKey = locationKey										// Configurando detectores de eventos 					actualPin.addEventListener(MouseEvent.ROLL_OVER, onPinMouseOverHandler, false, 0, true);				}				else				{					// Mostrando mensaje de error					actualMarker.errorMessage_txt.visible = true;										// Activando detectores de eventos e inhabilitando boton de envio					(actualMarker.sendButton as SimpleButton).addEventListener(MouseEvent.CLICK, sendUserMessageToServer);					(actualMarker.sendButton as SimpleButton).enabled = true;					(actualMarker.sendButton as SimpleButton).useHandCursor = true;										// Invisivilizando indicador de actividad					(actualMarker.sendMessageActivityIndicator as MovieClip).visible = false;				}			}			catch(e:Error)			{				debug(e.toString());				throw new Error(e.toString());			}		}				/**		 * @event		 * Ejecuta acciones una cuando el usario hace MOUSE_DOWN sobre el mapa		 */		private function onMapDragHandler(evt:MouseEvent = null):void 		{			if(!isLockMapControl) {				//this.addEventListener(Event.ENTER_FRAME, checkBoundsCollition);					highResolutionMap.startDrag();			}		}				/**		 * @event		 * Ejecuta acciones una cuando el usario hace MOUSE_UP sobre el mapa		 */		private function onMapDropHandler(evt:MouseEvent = null):void 		{				if(!isLockMapControl) {				//this.removeEventListener(Event.ENTER_FRAME, checkBoundsCollition);					highResolutionMap.stopDrag();			}		}				private function onMapMoveHandler(evt:MouseEvent = null):void 		{			if(!isMapMoveCancel)			{				var isMapOutOfBounds:Boolean = false;				var actualMapPosition:Point = new Point(highResolutionMap.x, highResolutionMap.y);								if(highResolutionMap.x + highResolutionMap.width / 2 < stage.x + stage.stageWidth + 20) {					trace("El mapa se ha salido de la frontera derecha");					highResolutionMap.x += 10;					isMapOutOfBounds = true;				} else if(highResolutionMap.x - highResolutionMap.width / 2 > stage.x - 20) {					trace("El mapa se ha salido de la frontera izquierda");					highResolutionMap.x -= 10;					isMapOutOfBounds = true;				} else if(highResolutionMap.y + highResolutionMap.height / 2 < stage.y + stage.stageHeight + 20) {					trace("El mapa se ha salido de la frontera superior");					highResolutionMap.y += 10;					isMapOutOfBounds = true;				} else if(highResolutionMap.y - highResolutionMap.height / 2 > stage.y - 20) {					trace("El mapa se ha salido de la frontera inferior");					highResolutionMap.y -= 10;					isMapOutOfBounds = true;				}								// Comprobando si el mapa se ha salido de las fronteras				if(isMapOutOfBounds) {					onMapDropHandler();				}			}		}				/**		 * @event		 * Comprueba que el mapa no se salga de las fronteras de la pnatalla		 */		private function checkBoundsCollition(evt:Event = null):void		{			var isMapOutOfBounds:Boolean = false;			var actualMapPosition:Point = new Point(highResolutionMap.x, highResolutionMap.y);						if((highResolutionMap.x + highResolutionMap.width) - 20 / 2 < stage.stageWidth) 			{				trace("[checkBoundsCollition]: El mapa se ha salido de la frontera derecha");				mapOutOfBoundsType = DataModel.MAP_OUT_OF_BOUNDS_FROM_RIGHT;				highResolutionMap.x += 10;				isMapOutOfBounds = true;			} 			else if((highResolutionMap.x - highResolutionMap.width / 2) + 20 > stage.x) 			{				trace("[checkBoundsCollition]: El mapa se ha salido de la frontera izquierda");				mapOutOfBoundsType = DataModel.MAP_OUT_OF_BOUNDS_FROM_LEFT;				highResolutionMap.x -= 10;				isMapOutOfBounds = true;			} 			else if((highResolutionMap.y + highResolutionMap.height / 2) - 20 < stage.stageHeight) 			{				trace("[checkBoundsCollition]: El mapa se ha salido de la frontera inferior");				mapOutOfBoundsType = DataModel.MAP_OUT_OF_BOUNDS_FROM_BOTTOM;				highResolutionMap.y += 10;				isMapOutOfBounds = true;			} 			else if((highResolutionMap.y - highResolutionMap.height / 2) + 20 > stage.y) 			{				trace("[checkBoundsCollition]: El mapa se ha salido de la frontera superior");				mapOutOfBoundsType = DataModel.MAP_OUT_OF_BOUNDS_FROM_TOP;				highResolutionMap.y -= 10;				isMapOutOfBounds = true;			}						// Comprobando si el mapa se ha salido de las fronteras			if(isMapOutOfBounds) 			{				// Cancelando movimiento del mapa automatico				isMapMoveCancel = true;								// Eliminando detectores de eventos				this.removeEventListener(Event.ENTER_FRAME, checkBoundsCollition);								// Eliminando todos los tweens aplicados al mapa				Tweener.removeTweens(highResolutionMap);				trace("Eliminando Tween porque el mapa se ha salido de los limites");								// Realizando animacion del objeto de loader visual				//Tweener.addTween(vetustaVisualLoader, {alpha:0, time:1, transition:"easeOutCubic", onComplete:removeLoader});								// Ajustando automaticamente el mapa a sus limites minimos				var d:Number = 0;				if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_RIGHT) {					d = (stage.stageWidth - highResolutionMap.x) - highResolutionMap.width / 2;					Tweener.addTween(highResolutionMap, {x:highResolutionMap.x + d, time:.3, transition:"easeOutCubic", onComplete:successAutomaticAdjustmentMap});				}								if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_LEFT) {					d = (highResolutionMap.x - stage.x) - highResolutionMap.width / 2;					Tweener.addTween(highResolutionMap, {x:highResolutionMap.x - d, time:.3, transition:"easeOutCubic", onComplete:successAutomaticAdjustmentMap});				}								if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_TOP) {					d = (highResolutionMap.y - stage.y) - highResolutionMap.height / 2;					Tweener.addTween(highResolutionMap, {y:highResolutionMap.y - d, time:.3, transition:"easeOutCubic", onComplete:successAutomaticAdjustmentMap});				}								if(mapOutOfBoundsType == DataModel.MAP_OUT_OF_BOUNDS_FROM_BOTTOM) {					d = (stage.stageHeight - highResolutionMap.y) - highResolutionMap.height / 2;					Tweener.addTween(highResolutionMap, {y:highResolutionMap.y + d, time:.3, transition:"easeOutCubic", onComplete:successAutomaticAdjustmentMap});				}			}		}				private function successAutomaticAdjustmentMap():void		{			if(!isAutomaticAdjustmentExcecuted) {				isAutomaticAdjustmentExcecuted = true;				removeEnterFrameForBoundsCollition(true);			}		}				/**		 * @event		 * Ejecuta acciones una vez terminada las descargas de ficheros externos			 */		public function onBulkElementLoadedHandler(evt:Event):void 		{			trace("VetustaMusicExperienceAppController->onBulkElementLoadedHandler()");						// Desactivando detectores de eventos			bulkLoader.removeEventListener(BulkLoader.COMPLETE, onBulkElementLoadedHandler);			bulkLoader.removeEventListener(BulkLoader.PROGRESS, onBulkElementProgressHandler);				bulkLoader.removeEventListener(BulkLoader.ERROR, onErrorHandler);						// Realizando animacion del objeto de loader visual			Tweener.addTween(vetustaVisualLoader, {alpha:0, time:1, transition:"easeOutCubic", onComplete:removeLoader});							// Visualizando wizard			wizardModalWindow.visible = true;		}				private function removeLoader():void {			trace("Eliminando loader visual del escenario...");			StageManager.getInstance().removeObject(DataModel.COMPONENT_VISUAL_LOADER_HASH);							}						/**		 * @event		 * Ejecuta acciones mientras se descargan los ficheros externos			 */		public function onBulkElementProgressHandler(evt:BulkProgressEvent):void 		{						var percent:uint = Math.floor((evt.totalPercentLoaded) * 100) ;			vetustaVisualLoader.bar_mc.gotoAndStop(percent);			if(evt.bytesLoaded == evt.bytesTotal)				vetustaVisualLoader.bar_mc.gotoAndStop(100);		}												/**		 * @event		 * Ejecuta acciones cuando se captura algun error en la descarga de ficheros externos		 */		public function onErrorHandler(evt:Event):void {				throw new Error(evt);		}				/**		 * @event		 * Cuenta los segundos de la cancion que esta sonando para transformarlo luego en un indice para el array de numeros		 */		private function countSeconds(evt:TimerEvent):void		{			soundSecondCounter++;			trace("Cantidad segundos de reproduccion: ", soundSecondCounter);		}				private function userSelectedTrack(evt:MouseEvent):void 		{			// Obteniendo indice del sonido 			trace("Track selected: " + evt.target.name);			var trackInstanceName:String = evt.target.name;			var index:int = trackInstanceName.lastIndexOf("_");			var trackIndexInDiscSelected:uint = uint(trackInstanceName.substr(index + 1));			trace("Track index: ", trackIndexInDiscSelected);						// Actualizando variable global para cancion seleccionada por el usuario			playingSoundIndex = trackIndexInDiscSelected;					// Creo una clase correspondiente al objeto en la biblioteca del swf			var Pin:Class = mainMovieClip.loaderInfo.applicationDomain.getDefinition("Pin") as Class;						// Creando PIN asociado con la cancion seleccionada por el usuario			var pin:MovieClip = new Pin();			//pin.gotoAndStop(trackIndexInDiscSelected + 1);			trace(pin.toString());						// Reproduciendo sonido seleccionado por el usuario			toolBar.playerComponent.loadSoundByIndex(trackIndexInDiscSelected, pin);						// Actualizando tema escogido por el usuario en el playlist de la barra de herramientas			toolBar.playlistComponent.updateInterfaceForTrackSelected(trackIndexInDiscSelected);		}				private function changeWizardToNextScreen(evt:Event):void  		{			wizardModalWindow.nextFrame();			(wizardModalWindow.beginVetustaExperience as MovieClip).visible = true;			(wizardModalWindow.modalBackground as MovieClip).visible = false;			toolBar.playerComponent.removeEventListener(DataModel.SOUND_SELECTED_LOADED, changeWizardToNextScreen);		}	}}