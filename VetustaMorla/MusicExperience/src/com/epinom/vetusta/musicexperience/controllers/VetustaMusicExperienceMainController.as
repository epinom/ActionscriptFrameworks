package com.epinom.vetusta.musicexperience.controllers{		import caurina.transitions.Tweener;		import com.digitalsurgeons.loading.BulkLoader;	import com.digitalsurgeons.loading.BulkProgressEvent;	import com.epinom.vetusta.musicexperience.data.DataModel;	import com.epinom.vetusta.musicexperience.data.HashMap;	import com.epinom.vetusta.musicexperience.ui.MapCell;		import fl.controls.Slider;	import fl.events.SliderEvent;		import flash.display.Bitmap;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.net.URLRequest;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.utils.Timer;		public class VetustaMusicExperienceMainController extends MovieClip	{		private var bulkLoader:BulkLoader;		private var cellIdList:Array;		private var cellHashMap:HashMap;		private var secondCounter:uint;		private var map:Sprite;				public function VetustaMusicExperienceMainController()		{			super();			trace("VetustaMusicExperienceMainController->VetustaMusicExperienceMainController()");			// Inicializando propiedades			cellIdList = new Array();			cellHashMap = new HashMap();			secondCounter = 0;			map = new Sprite();			addChild(map);						// Actualizando la referencia al escenario de la pelicula principal			DataModel.getInstance().stage = this.stage;						// Obteniendo loader principal			if(BulkLoader.getLoader(DataModel.MAIN_BULKLOADER_NAME)) {				bulkLoader = BulkLoader.getLoader(DataModel.MAIN_BULKLOADER_NAME);			} else {				bulkLoader = new BulkLoader(DataModel.MAIN_BULKLOADER_NAME);				bulkLoader.logLevel = BulkLoader.LOG_INFO;			}						// Inicializando aplicacion			init();		}				/**		 * @event		 * Inicializa la aplicacion			 */		private function init():void		{			// Generando listado con nombres de imagenes del mapa			runImagesGenerator();						// Haciendo peticion multiple de imagenes			cellHashMap.actionsForElements(loadImageToMapCell);			// Configurando listeners			zoom_sld.addEventListener(SliderEvent.CHANGE, onSliderChangeHandler); 			map.addEventListener(MouseEvent.MOUSE_DOWN, onMapDragHandler);			map.addEventListener(MouseEvent.MOUSE_UP, onMapDropHandler);			bulkLoader.addEventListener(BulkLoader.COMPLETE, onBulkElementLoadedHandler);			bulkLoader.addEventListener(BulkLoader.PROGRESS, onBulkElementProgressHandler);			bulkLoader.addEventListener(BulkLoader.ERROR, onErrorHandler);			// Adicionando loader a la pelicula, la clase VetustaVisualLoader es el identificador de la biblioteca del objeto loader en la pelicula "app.swf"			if(DataModel.getInstance().visualLoader == null)			{				DataModel.getInstance().visualLoader = new VetustaVisualLoader();				DataModel.getInstance().visualLoader.x = this.stage.stageWidth / 2 ;				DataModel.getInstance().visualLoader.y = this.stage.stageHeight / 2 ;				this.addChild(DataModel.getInstance().visualLoader);				}						// Iniciando peticion multiple de imagenes			bulkLoader.start();			trace("************************ ok ************************");		}				/**		 * @method		 * Genera los nombre de imagenes de todas las celdas del mapa.		 * Crea Tabla Hash con objetos que representa las celdas del mapa		 */		private function runImagesGenerator():void		{			// Configurando variables para el calculo de identificador de imagen			var letterIndex:uint = 0;			var blockIndex:uint = 0;			var cellRowIndex:uint = 0;			var cellColumnIndex:uint = 0;			var actualLetter:String = "";			var actualBlockId:String = "";			var actualCellRowId:String = "";			var actualCellColumnId:String = "";			var imageName:String = ""; 			var counter:uint = 0;						// Adicionando peticiones al loader multiple			for (var i:int = 0; i < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; i++) 			{				if(i == 3)					break;								// Calculando el indice para obtener la letra del cuadrante				letterIndex = i % 3;								// Obteniendo letra del cuadrante				actualLetter = DataModel.LETTERS_BLOCK_LIST[letterIndex];								for (var j:int = 0; j < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; j++) 				{					if(j == 3)						break;										// Calculando el ID del bloque					blockIndex = j % 3;										// Obteniendo el string del ID del bloque					actualBlockId = blockIndex.toString();										for (var k:int = 0; k < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; k++) 					{						// Calculando el indice de la celda en las filas						cellRowIndex = k;												// Obteniendo el string del ID de la celda en las filas						actualCellRowId = DataModel.CELLS_ID_LIST[cellRowIndex];												for (var i2:int = 0; i2 < DataModel.TOTAL_CELLS_X_SIDE_BLOCK; i2++) 						{							// Calculando el indice de la celda en las columnas							cellColumnIndex = i2;														// Obteniendo el string del ID de la celda en las columnas							actualCellColumnId = DataModel.CELLS_ID_LIST[cellColumnIndex];														// Obteniendo el punto con la posicion del bloque en el mapa							var cellPoint:Point = offsetCellPointOfMap(letterIndex, blockIndex, cellRowIndex, cellColumnIndex);														// Creando objeto que representa una celda del mapa							var mapCell:MapCell = new MapCell();							mapCell.idCell = actualLetter + actualBlockId + "-" + actualCellRowId + actualCellColumnId;							mapCell.idGrid = actualCellRowId + actualCellColumnId;							mapCell.idBlock = actualLetter + actualBlockId;							mapCell.imageName = actualLetter + actualBlockId + "-" + actualCellRowId + actualCellColumnId + ".jpg";							//mapCell.urlImageServer = DataModel.URL_ACTIVE_DOMAIN + DataModel.URL_RELATIVE_FOR_MAP_IMAGES + mapCell.imageName;							mapCell.urlImageServer = DataModel.URL_RELATIVE_FOR_MAP_IMAGES + mapCell.imageName;							mapCell.image = null;							mapCell.mc = null;							mapCell.loadPriority = 0;							mapCell.offsetX = cellPoint.x;							mapCell.offsetY = cellPoint.y;							// Adicionando nombre de imagen a la lista							cellHashMap.add(mapCell.idCell, mapCell);														//trace(counter + ".- ", mapCell.imageName + "		x: " + mapCell.offsetX + "	  	  y: " + mapCell.offsetY);							counter++;						}					}				}				}			}				/**		 * @method		 * Calcula la posicion de la celda en el mapa		 */		private function offsetCellPointOfMap(letterIndex:uint, blockIndex:uint, cellRowIndex:uint, cellColumnIndex:uint):Point		{				// Inicializando punto			var cellPoint:Point = new Point();						// Calculando posicion de la celda en el mapa segun los parametros 			cellPoint.x = (blockIndex * DataModel.MAP_BLOCK_WIDTH) + (cellColumnIndex * DataModel.MAP_CELL_WIDTH);			cellPoint.y = (letterIndex * DataModel.MAP_BLOCK_HEIGHT) + (cellRowIndex * DataModel.MAP_CELL_HEIGHT);				return cellPoint;		}				/**		 * @method		 * Hace la peticion de cada una de las imagenes del mapa al servidor, a traves del gestor multiple de ficheros externos		 */		public function loadImageToMapCell(mapCell:MapCell):void		{			// Lanzando la carga de la imagen			bulkLoader.add(new URLRequest(mapCell.urlImageServer), {id: mapCell.idCell});		}				/**		 * @method		 * Obtiene la imagen cargado por el gestor de carga de ficheros externo segun el ID de la imagen.		 * Posiciona la imagen y la agrega al escenario		 */		public function setImageToMapCell(mapCell:MapCell):void		{			// Obteniendo la imagen segun su identificador de celda			mapCell.image = bulkLoader.getBitmap(mapCell.idCell);			mapCell.image.smoothing = true;						// Posicionando la imagen y adicionandola en la posicion de celda calculada			mapCell.image.x = mapCell.offsetX;			mapCell.image.y = mapCell.offsetY;			map.addChild(mapCell.image);			addChild(zoom_sld);		}				private function onSliderChangeHandler(evt:SliderEvent):void		{			trace("Escala de mapa: " + evt.value);			trace("int((evt.value * .01)*10)/10): ", int((evt.value * .01)*10)/10);			map.scaleX = evt.value * .01;			map.scaleY = evt.value * .01;						trace("map.scaleX: ", map.scaleX);			trace("map.scaleY: ", map.scaleY);		}				/**		 * @event		 * Ejecuta acciones una vez terminada las descargas de ficheros externos			 */		public function onBulkElementLoadedHandler(evt:Event):void 		{			trace("VetustaMusicExperienceMainController->onBulkElementLoadedHandler()");						// Desactivando detectores de eventos			bulkLoader.removeEventListener(BulkLoader.COMPLETE, onBulkElementLoadedHandler);			bulkLoader.removeEventListener(BulkLoader.PROGRESS, onBulkElementProgressHandler);				bulkLoader.removeEventListener(BulkLoader.ERROR, onErrorHandler);						// Realizando animacion del objeto de loader visual			Tweener.addTween(DataModel.getInstance().visualLoader, {alpha:0, time:1, transition:"easeOutCubic"});						/* 				Adicionando la imagen cargada a cada celda del mapa que esta almacena en el hashmap, 				se utiliza un demonio para esta funcion, o sea, se le pasa una funcion como referencia "setImageToMapCell", 				para que se le aplique a cada elemento del hashmap.			*/			cellHashMap.actionsForElements(setImageToMapCell);		}				/**		 * @event		 * Ejecuta acciones mientras se descargan los ficheros externos			 */		public function onBulkElementProgressHandler(evt:BulkProgressEvent):void 		{						var percent:uint = Math.floor((evt.totalPercentLoaded) * 100) ;			DataModel.getInstance().visualLoader.bar_mc.gotoAndStop(percent);			if(evt.bytesLoaded == evt.bytesTotal)				DataModel.getInstance().visualLoader.bar_mc.gotoAndStop(100);		}													/**		 * @event		 * Ejecuta acciones cuando se captura algun error en la descarga de ficheros externos		 */		public function onErrorHandler(evt:Event):void {				throw new Error(evt);		}				/**		 * @event		 * Ejecuta acciones una cuando el usario hace MOUSE_DOWN sobre el mapa		 */		public function onMapDragHandler(evt:MouseEvent):void {				map.startDrag();		}				/**		 * @event		 * Ejecuta acciones una cuando el usario hace MOUSE_UP sobre el mapa		 */		public function onMapDropHandler(evt:MouseEvent):void {				map.stopDrag();		}	}}